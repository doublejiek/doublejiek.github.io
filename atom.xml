<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>路长且远</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-23T14:41:39.110Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Doublejiek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记</title>
    <link href="http://yoursite.com/2019/07/10/%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/10/笔记/</id>
    <published>2019-07-10T08:54:37.000Z</published>
    <updated>2019-07-23T14:41:39.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><h4 id="Hibernate（JPA）"><a href="#Hibernate（JPA）" class="headerlink" title="Hibernate（JPA）"></a>Hibernate（JPA）</h4><blockquote><p>一个开源的对象关系映射框架</p><p>对JDBC进行了非常轻量级的对象封装</p><p>将JacaBean对象和数据库的表建立对应关系</p><p>它是一个优秀的Java持久化层（DAO）解决方案</p><p>是当今主流的对象——关系映射工具</p><p>它简化了JDBC繁琐的编码，将数据库的连接信息都放置在配置文件中</p></blockquote><a id="more"></a><p>####Mybatis</p><blockquote><p>MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。</p><p>MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。</p><p>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。</p></blockquote><p>####Hibernate和Mybatis的区别</p><blockquote><p>一、MyBatis 真正实现了java代码和sql的分离</p><p>二、Hibernate 是全自动的，MyBatis是半自动的 Hibernate实现了部分自动生成SQL</p><p>三、SQL优化上 MyBatis 强于 Hibernate</p><pre><code>1、MyBatis优化维护方便 SQL全存在于XML中 不需要修改源代码2、开发效率上 Hibernate略强于mybatiss3、从性能上说，对性能要求不是很高的项目来说，因为Mybatis全都   是自己手写的SQL 因此性能相对较高，   Hibernate更加提倡使用HQL HQL往往会查询更多的字段，性能反而   较低。4、从更新功能上来说 Hibernate会更新所有字段 而MyBatis可以   只需要更新意个字段5、Hibernate相对来说简化了DAO类的书写</code></pre></blockquote><p>##Spring MVC</p><blockquote><p>SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，将Web层进行职责解耦。（请求驱动即 请求-响应模型）</p><p>浏览器识别程序的桥梁</p></blockquote><p>Model    实体类      数据库的映射类</p><p>View     视图        页面</p><p>Controller 控制器      通信代码</p><h2 id="Spring-一站式框架"><a href="#Spring-一站式框架" class="headerlink" title="Spring 一站式框架"></a>Spring 一站式框架</h2><p>web层：Spring MVC</p><p>业务层（Service）：Spring的Bean管理，声明式事务</p><p>持久层（DAO）：ORM模块、JDBC模板</p><blockquote><p>对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的软件开发方法发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法。ORM技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化。</p></blockquote><p>##Maven<br>Maven 导入jar包</p><p>##注解</p><p>@RequestMapper 地址路由连接器</p><blockquote><pre><code>@RequestMapping(“/”)`</code></pre><p>这个(“/”) 就是浏览器要寻找的程序地址</p></blockquote><p>@ResponseBody 注解就是返回的数据格式为json<br>没加代表返回的数据格式是页面</p><blockquote><pre><code>@RequestMapping(&quot;/json&quot;)@ResponseBody</code></pre></blockquote><h3 id="IOC注解"><a href="#IOC注解" class="headerlink" title="IOC注解"></a>IOC注解</h3><h4 id="Component-：组件"><a href="#Component-：组件" class="headerlink" title="@Component ：组件"></a>@Component ：组件</h4><p>其三个衍生注解（功能类似），修饰类：</p><blockquote><p>@Controller ：web层（带有@Controller的程序类才能被浏览器识别）</p><p>@Service    ：service层</p><p>@Repository ：dao层</p></blockquote><h4 id="属性注入的注解"><a href="#属性注入的注解" class="headerlink" title="属性注入的注解"></a>属性注入的注解</h4><p>普通属性：</p><blockquote><p>@Value        ：设置普通属性的值</p></blockquote><p>对象类型属性：</p><blockquote><p>@Autowired    ：设置对象类型的属性值，但 是按照类型 完成属性注入（相当于引用这个类）</p><p>@Qualifier（value=””）：按名称完成属性注入</p><p>@Resource（name=””）  ：按名称完成属性注入</p></blockquote><h4 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h4><p>Bean作用范围的注解</p><blockquote><p>@Scope        ：作用范围</p><p>@Scope(singleton)     ：默认单例</p><p>@Scope(prototype)     ：多例</p></blockquote><p>##jquery三大选择器<br>Id选择器 ——》 $(#id)</p><p>Class 选择器 –》 $(.class)</p><p>Element 标签选择器 $(Element ) </p><blockquote><p>jquery 绑定点击事件</p></blockquote><pre><code>$(&quot;#btn&quot;).click(function(){ alert(“点击了”)     });</code></pre><p>jQuery方法</p><pre><code>Val()  取值 val(123) 设置attr()  取属性值  attr(“name”,”kd”) 设置Append() 追加方法Html()替换html方法Each(data,function(index,item))  循环方法</code></pre><p>##Ajax</p><p>Ajax 是异步请求后台数据的方法，可以局部刷新页面</p><blockquote><p>$.post(地址,参数,回调地址)</p><p>Get 也一样</p><p>$.get(地址,参数,回调地址)</p></blockquote><pre><code> $.post(&quot;/loginCheck&quot;,{&quot;name&quot;:name,&quot;pwd&quot;:pwd},function(json){    //成功跳转页面，不成功则登录页面弹出对话框      if(json.msg==&quot;yes&quot;){         location.href=&quot;/user/list&quot;;      }else{          alert(&quot;登录失败&quot;)      }  })// 登录验证@RequestMapping(&quot;/loginCheck&quot;)@ResponseBodypublic Map&lt;String, Object&gt;  loginCheck(String name,String pwd) {    Map&lt;String, Object&gt;map=new HashMap&lt;&gt;();    if(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)){        map.put(&quot;msg&quot;, &quot;yes&quot;);    }else{        map.put(&quot;msg&quot;, &quot;no&quot;);        //控制台        System.out.println(&quot;登录失败&quot;);    }        return map;}</code></pre><h2 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h2><p>IOC：控制反转</p><pre><code>将对象的创建权反转给Spring</code></pre><ol><li>下载jar开发包</li><li>引入jar包</li><li>创建接口和实现类</li><li>将接口和实现类交给Spring管理</li><li>编写测试类</li></ol><p>DI：依赖注入</p><pre><code>前提必须有IOC环境，Spring管理这个类的时候将这个类的依赖属性注入（设置）进来</code></pre><p>AOP（面向切面编程）：AOP的开发对程序进行扩展</p><h2 id="Spring开发包"><a href="#Spring开发包" class="headerlink" title="Spring开发包"></a>Spring开发包</h2><ol><li><p>dosc：开发规范和API</p></li><li><p>libs：jar和源码</p></li><li><p>shema：配置文件和约束</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h2&gt;&lt;h2 id=&quot;ORM&quot;&gt;&lt;a href=&quot;#ORM&quot; class=&quot;headerlink&quot; title=&quot;ORM&quot;&gt;&lt;/a&gt;ORM&lt;/h2&gt;&lt;h4 id=&quot;Hibernate（JPA）&quot;&gt;&lt;a href=&quot;#Hibernate（JPA）&quot; class=&quot;headerlink&quot; title=&quot;Hibernate（JPA）&quot;&gt;&lt;/a&gt;Hibernate（JPA）&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;一个开源的对象关系映射框架&lt;/p&gt;
&lt;p&gt;对JDBC进行了非常轻量级的对象封装&lt;/p&gt;
&lt;p&gt;将JacaBean对象和数据库的表建立对应关系&lt;/p&gt;
&lt;p&gt;它是一个优秀的Java持久化层（DAO）解决方案&lt;/p&gt;
&lt;p&gt;是当今主流的对象——关系映射工具&lt;/p&gt;
&lt;p&gt;它简化了JDBC繁琐的编码，将数据库的连接信息都放置在配置文件中&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://yoursite.com/2019/07/03/JVM/"/>
    <id>http://yoursite.com/2019/07/03/JVM/</id>
    <published>2019-07-03T07:00:01.000Z</published>
    <updated>2019-07-03T08:34:43.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java由四方面组成："><a href="#java由四方面组成：" class="headerlink" title="java由四方面组成："></a>java由四方面组成：</h1><ol><li><p>Java编程语言</p></li><li><p>Java类文件格式</p></li><li><p>Java虚拟机</p></li><li><p>Java应用程序接口(Java API)</p></li></ol><p>关系如下图：</p><p><img src="https://s2.ax1x.com/2019/07/03/ZtdL4S.gif" alt="image text"></p><h1 id="1-Java虚拟机体系结构"><a href="#1-Java虚拟机体系结构" class="headerlink" title="1.Java虚拟机体系结构"></a>1.Java虚拟机体系结构</h1><a id="more"></a><ul><li>每个JVM都有两种机制</li></ul><p>①类装载子系统：装载具有适合名称的类或接口</p><p>②执行引擎：负责执行包含在已装载的类或接口中的指令 </p><p>#2.Java代码编译和执行的整个过程</p><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。</p><p>（1）Java代码到JVM字节码（编译）</p><p><img src="https://s2.ax1x.com/2019/07/03/ZtwnD1.jpg" alt="image text"></p><p>（2）JVM字节码到机器码（执行）</p><p><img src="https://s2.ax1x.com/2019/07/03/Ztw88e.jpg" alt="image text"></p><h3 id="编译到运行的三个机制"><a href="#编译到运行的三个机制" class="headerlink" title="编译到运行的三个机制"></a>编译到运行的三个机制</h3><p>（1）Java源码编译机制</p><p>①分析和输入到符号表</p><p>②注解处理</p><p>③语义分析和生成CLASS文件</p><p>最后生成的class文件由以下部分组成：</p><p>①结构信息：包括class文件格式版本号及各部分的数量与大小的信息</p><p>②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</p><p>③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</p><p>（2）类加载机制</p><p>1.装载load 。目的是生成类加载实例id </p><p>2.链接 ，检测字节码格式以及内部调用匹配情况。静态变量初始化 </p><p>3.初始化。主要是类加载器加载类的顺序。 </p><p><img src="https://s2.ax1x.com/2019/07/03/ZtwfaV.jpg" alt></p><p><img src="https://s2.ax1x.com/2019/07/03/ZtwTxJ.png" alt></p><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><p>（3）类执行机制</p><p>JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：</p><p><img src="http://hi.csdn.net/attachment/201009/25/0_1285425270cQVC.gif" alt></p><h1 id="3-JVM内存管理及垃圾回收机制"><a href="#3-JVM内存管理及垃圾回收机制" class="headerlink" title="3.JVM内存管理及垃圾回收机制"></a>3.JVM内存管理及垃圾回收机制</h1><p>JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用）</p><p><img src="https://img-blog.csdn.net/20131106010426437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。</p><h3 id="垃圾检测："><a href="#垃圾检测：" class="headerlink" title="垃圾检测："></a>垃圾检测：</h3><p>可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象本地方法中引用的对象等。</p><p>JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。</p><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p><strong>1.标记-清除（Mark-sweep）</strong></p><p>分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。</p><p>缺点：效率低；碎片化严重</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174234266-1575111287.png" alt></p><p><strong>2.复制（Copying）</strong></p><p>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。</p><p>缺点： 持续复制，效率低。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174237703-328169343.png" alt></p><p><strong>3.Mark-Compact 标记-压缩(老年代使用)</strong></p><p>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239219-1187241876.png" alt></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><strong>1.Serial（串行GC）收集器</strong></p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174240391-864339858.png" alt></p><p><strong>2.ParNew（并行GC）收集器</strong></p><p>Serial 的多线程版本，新生代并行，复制算法，老年代串行，标记-压缩算法。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174244797-1533472044.png" alt></p><p><strong>3.Parallel Scavenge(并行回收GC)收集器</strong></p><p>类似ParNew,他关注的系统的吞吐量，也可以通过参数实现自适应性调节控制吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p><strong>4.Parallel Old 收集器</strong></p><p>一种以最短停顿为目标的收集器</p><blockquote><p>初始标记（initial mark） stop-the-world,标记gc roots 直接关联对象。</p><p>并发标记（concurrent mark）trace gc roots</p><p>重新标记（remark） stop-the-world</p><p>并发清除（concurrent sweep）</p></blockquote><p>优点：并发收集，低停顿；</p><p>缺点：大量碎片；并发阶段；</p><p><strong>5.CMS 收集器</strong></p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：</p><p>①.初始标记(CMS initial mark)</p><p>②.并发标记(CMS concurrenr mark)</p><p>③.重新标记(CMS remark)</p><p>④.并发清除(CMS concurrent sweep)</p><p><strong>6.G1 回收器（Garbage First）</strong></p><p>面向服务器的收集器，主要针对配备多处理器 及大容量的内存的机器，以极高概率，满足GC停顿时间，且具备高吞吐量。</p><blockquote><p><strong>空间整合</strong>，G1收集器采用<strong>标记整理算法</strong>，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></blockquote><blockquote><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></blockquote><p><strong>收集步骤：</strong></p><ol><li><p>标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)。</p></li><li><p>Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p></li><li><p>Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p></li></ol><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174249203-774809988.png" alt></p><ol><li><p>Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p></li><li><p>Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p></li></ol><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174250656-1729618538.png" alt></p><p>复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174252078-703896755.png" alt></p><hr><p>参考：</p><p><a href="https://blog.csdn.net/hui_yan2012/article/details/70194449" target="_blank" rel="noopener">https://blog.csdn.net/hui_yan2012/article/details/70194449 </a></p><p><a href="https://blog.csdn.net/qq_33384065/article/details/80282023" target="_blank" rel="noopener">https://blog.csdn.net/qq_33384065/article/details/80282023</a></p><p><a href="https://blog.csdn.net/supera_li/article/details/45747589" target="_blank" rel="noopener">https://blog.csdn.net/supera_li/article/details/45747589</a></p><p><a href="https://blog.csdn.net/java2000_wl/article/details/8030172" target="_blank" rel="noopener">https://blog.csdn.net/java2000_wl/article/details/8030172</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java由四方面组成：&quot;&gt;&lt;a href=&quot;#java由四方面组成：&quot; class=&quot;headerlink&quot; title=&quot;java由四方面组成：&quot;&gt;&lt;/a&gt;java由四方面组成：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java编程语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java类文件格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java应用程序接口(Java API)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/03/ZtdL4S.gif&quot; alt=&quot;image text&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Java虚拟机体系结构&quot;&gt;&lt;a href=&quot;#1-Java虚拟机体系结构&quot; class=&quot;headerlink&quot; title=&quot;1.Java虚拟机体系结构&quot;&gt;&lt;/a&gt;1.Java虚拟机体系结构&lt;/h1&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>博客的搭建</title>
    <link href="http://yoursite.com/2019/07/02/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/07/02/博客的搭建/</id>
    <published>2019-07-02T06:22:02.000Z</published>
    <updated>2019-07-02T06:43:32.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitPage的优点"><a href="#GitPage的优点" class="headerlink" title="GitPage的优点"></a>GitPage的优点</h2><ul><li>可以绑定你的域名(但暂时貌似只能绑定一个)。</li><li>简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。</li><li>轻量级的博客系统，没有麻烦的配置</li><li>使用标记语言，比如 Markdown</li></ul><a id="more"></a><h2 id="hexo-构建静态文件无法生成-index-html-等文件"><a href="#hexo-构建静态文件无法生成-index-html-等文件" class="headerlink" title="hexo 构建静态文件无法生成 index.html 等文件"></a>hexo 构建静态文件无法生成 index.html 等文件</h2><h5 id="查看npm安装hexo插件情况"><a href="#查看npm安装hexo插件情况" class="headerlink" title="查看npm安装hexo插件情况"></a>查看npm安装hexo插件情况</h5><blockquote><p>npm ls –depth 0</p></blockquote><p>一些插件未安装</p><p><img src="http://huihut-img.oss-cn-shenzhen.aliyuncs.com/ganningZHexoNPMls.png" alt="Image text"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>逐一安装缺失的包</p><blockquote><p> npm install hexo-generator-archive –save</p><p> npm install hexo-xxx-xxx –save</p><p> …</p></blockquote><hr><h2 id="执行hexo-server出现Usage-hexo-”的提示"><a href="#执行hexo-server出现Usage-hexo-”的提示" class="headerlink" title="执行hexo server出现Usage: hexo ”的提示"></a>执行hexo server出现Usage: hexo <command>”的提示</h2><p>出现这个原因是因为没有安装 hexo-server</p><h1 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h1><blockquote><p>npm install hexo-server –save</p></blockquote><hr><p>#部署GitHub</p><p>运行时出错，是没有添加sshkey</p><h3 id="一、生成新的SSH密钥"><a href="#一、生成新的SSH密钥" class="headerlink" title="一、生成新的SSH密钥"></a>一、生成新的SSH密钥</h3><p>1、打开Git Bash。</p><p>2、 进入.ssh 根目录下。</p><pre><code>cd ~/.ssh</code></pre><p>3、输入GitHub电子邮件地址，其中<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>是您关联的GitHub邮箱。</p><pre><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></pre><p>4、输入保存的密钥文件并接受默认文件地址，按Enter键</p><blockquote><p>// 用提供的电子邮件作为标签创建一个新的ssh密钥。（无需操作）</p></blockquote><blockquote><p>Generating public/private rsa key pair. </p></blockquote><blockquote><p>// 输入名称并按Enter键，其中hexo_rsa可自行设置</p></blockquote><blockquote><p>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):hexo_rsa</p></blockquote><p>5、输入安全密码，没有则为空，按Enter键进行下一步</p><blockquote><p>Enter passphrase (empty for no passphrase): [Type a passphrase]<br>Enter same passphrase again: [Type passphrase again]</p></blockquote><p><img src="https://segmentfault.com/img/bVbn2Yk?w=574&h=318" alt="Image text"></p><blockquote><p>Your identification has been saved in /home/you/.ssh/id_rsa.</p><p>Your public key has been saved in /home/you/.ssh/id_rsa.pub.</p><p>The key fingerprint is:</p><p>…………………此处是密钥内容…………………… <a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a></p></blockquote><p>此时，应该在默认路径下，生成了两个文件，一个是hexo_rsa，另一个是hexo_rsa.pub；</p><p>###二、将SSH密钥添加到SSH-Agent</p><p>在将新的SSH密钥添加到SSH-Agent管理密钥之前，您应该检查现有的SSH密钥。</p><pre><code>ls -al ~/ .ssh</code></pre><p>看下返回的结果中是否已经存在了.pub结尾的文件，如果没有需要生成一个新的，如果存在了，直接看将SSH密钥配置到Github账户；</p><p>6、启动ssh-agent，执行命令：</p><pre><code>eval $(ssh-agent -s)</code></pre><p><img src="https://image-static.segmentfault.com/248/865/2488652781-5c53c17548630_articlex" alt="Image text"></p><p>7、将SSH密钥添加到SSH-Agent,其中hexo_rsa是生成SSH设置的名称</p><pre><code>ssh-ADD~ /.ssh/hexo_rsa</code></pre><p>8、打开hexo_rsa.pub文件，复制其内容，然后打开Github账户，按图片步骤设置，最后将复制内容放置Key内容中，设置title，点击添加即可。</p><p><img src="https://image-static.segmentfault.com/234/007/2340075688-5c53c333cacd3_articlex" alt="Image text"></p><p>验证SSH链接是否成功，<br>输入命令：</p><pre><code>ssh -T git@github.com</code></pre><p>你将会看到</p><p><img src="https://image-static.segmentfault.com/166/300/1663009123-5c53c4d35cc8c_articlex" alt="Image text"></p><p>输入 “Yes”就ok了！</p><hr><p>###相关连接：<br><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitPage的优点&quot;&gt;&lt;a href=&quot;#GitPage的优点&quot; class=&quot;headerlink&quot; title=&quot;GitPage的优点&quot;&gt;&lt;/a&gt;GitPage的优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以绑定你的域名(但暂时貌似只能绑定一个)。&lt;/li&gt;
&lt;li&gt;简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。&lt;/li&gt;
&lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
&lt;li&gt;使用标记语言，比如 Markdown&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
