<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>路长且远</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-10T09:02:42.166Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Doublejiek</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>笔记</title>
    <link href="http://yoursite.com/2019/07/10/%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/07/10/笔记/</id>
    <published>2019-07-10T08:54:37.000Z</published>
    <updated>2019-07-10T09:02:42.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>Maven 导入jar包</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><blockquote><p>Hibernate（JPA）</p><p>Spring boot</p></blockquote><a id="more"></a><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><blockquote><p>SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，将Web层进行职责解耦。（请求驱动即 请求-响应模型）</p><p>浏览器识别程序的桥梁</p></blockquote><p>Model    实体类      数据库的映射类</p><p>View     视图        页面</p><p>Controller 控制器      通信代码</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>@Autowired 相当于引用这个类</p><p>带有@Controller的程序类才能被浏览器识别</p><p>@RequestMapper 地址路由连接器</p><blockquote><pre><code>@RequestMapping(“/”)`</code></pre><p>这个(“/”) 就是浏览器要寻找的程序地址</p></blockquote><p>@ResponseBody 注解就是返回的数据格式为json<br>没加代表返回的数据格式是页面</p><blockquote><pre><code>@RequestMapping(&quot;/json&quot;)@ResponseBody</code></pre></blockquote><h2 id="jquery三大选择器"><a href="#jquery三大选择器" class="headerlink" title="jquery三大选择器"></a>jquery三大选择器</h2><p>Id选择器 ——》 $(#id)</p><p>Class 选择器 –》 $(.class)</p><p>Element 标签选择器 $(Element ) </p><blockquote><p>jquery 绑定点击事件</p></blockquote><pre><code>$(&quot;#btn&quot;).click(function(){ alert(“点击了”)     });</code></pre><p>jQuery方法</p><pre><code>Val()  取值 val(123) 设置attr()  取属性值  attr(“name”,”kd”) 设置Append() 追加方法Html()替换html方法Each(data,function(index,item))  循环方法</code></pre><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax 是异步请求后台数据的方法，可以局部刷新页面</p><blockquote><p>$.post(地址,参数,回调地址)</p><p>Get 也一样</p><p>$.get(地址,参数,回调地址)</p></blockquote><pre><code> $.post(&quot;/loginCheck&quot;,{&quot;name&quot;:name,&quot;pwd&quot;:pwd},function(json){    //成功跳转页面，不成功则登录页面弹出对话框      if(json.msg==&quot;yes&quot;){         location.href=&quot;/user/list&quot;;      }else{          alert(&quot;登录失败&quot;)      }  })// 登录验证@RequestMapping(&quot;/loginCheck&quot;)@ResponseBodypublic Map&lt;String, Object&gt;  loginCheck(String name,String pwd) {    Map&lt;String, Object&gt;map=new HashMap&lt;&gt;();    if(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)){        map.put(&quot;msg&quot;, &quot;yes&quot;);    }else{        map.put(&quot;msg&quot;, &quot;no&quot;);        //控制台        System.out.println(&quot;登录失败&quot;);    }        return map;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h2&gt;&lt;p&gt;Maven 导入jar包&lt;/p&gt;
&lt;h2 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Hibernate（JPA）&lt;/p&gt;
&lt;p&gt;Spring boot&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM</title>
    <link href="http://yoursite.com/2019/07/03/JVM/"/>
    <id>http://yoursite.com/2019/07/03/JVM/</id>
    <published>2019-07-03T07:00:01.000Z</published>
    <updated>2019-07-03T08:34:43.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java由四方面组成："><a href="#java由四方面组成：" class="headerlink" title="java由四方面组成："></a>java由四方面组成：</h1><ol><li><p>Java编程语言</p></li><li><p>Java类文件格式</p></li><li><p>Java虚拟机</p></li><li><p>Java应用程序接口(Java API)</p></li></ol><p>关系如下图：</p><p><img src="https://s2.ax1x.com/2019/07/03/ZtdL4S.gif" alt="image text"></p><h1 id="1-Java虚拟机体系结构"><a href="#1-Java虚拟机体系结构" class="headerlink" title="1.Java虚拟机体系结构"></a>1.Java虚拟机体系结构</h1><a id="more"></a><ul><li>每个JVM都有两种机制</li></ul><p>①类装载子系统：装载具有适合名称的类或接口</p><p>②执行引擎：负责执行包含在已装载的类或接口中的指令 </p><p>#2.Java代码编译和执行的整个过程</p><p>开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。</p><p>（1）Java代码到JVM字节码（编译）</p><p><img src="https://s2.ax1x.com/2019/07/03/ZtwnD1.jpg" alt="image text"></p><p>（2）JVM字节码到机器码（执行）</p><p><img src="https://s2.ax1x.com/2019/07/03/Ztw88e.jpg" alt="image text"></p><h3 id="编译到运行的三个机制"><a href="#编译到运行的三个机制" class="headerlink" title="编译到运行的三个机制"></a>编译到运行的三个机制</h3><p>（1）Java源码编译机制</p><p>①分析和输入到符号表</p><p>②注解处理</p><p>③语义分析和生成CLASS文件</p><p>最后生成的class文件由以下部分组成：</p><p>①结构信息：包括class文件格式版本号及各部分的数量与大小的信息</p><p>②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</p><p>③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</p><p>（2）类加载机制</p><p>1.装载load 。目的是生成类加载实例id </p><p>2.链接 ，检测字节码格式以及内部调用匹配情况。静态变量初始化 </p><p>3.初始化。主要是类加载器加载类的顺序。 </p><p><img src="https://s2.ax1x.com/2019/07/03/ZtwfaV.jpg" alt></p><p><img src="https://s2.ax1x.com/2019/07/03/ZtwTxJ.png" alt></p><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><p>（3）类执行机制</p><p>JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><p>JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：</p><p><img src="http://hi.csdn.net/attachment/201009/25/0_1285425270cQVC.gif" alt></p><h1 id="3-JVM内存管理及垃圾回收机制"><a href="#3-JVM内存管理及垃圾回收机制" class="headerlink" title="3.JVM内存管理及垃圾回收机制"></a>3.JVM内存管理及垃圾回收机制</h1><p>JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用）</p><p><img src="https://img-blog.csdn.net/20131106010426437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p><p>垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。</p><h3 id="垃圾检测："><a href="#垃圾检测：" class="headerlink" title="垃圾检测："></a>垃圾检测：</h3><p>可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象本地方法中引用的对象等。</p><p>JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。</p><h3 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h3><p><strong>1.标记-清除（Mark-sweep）</strong></p><p>分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。</p><p>缺点：效率低；碎片化严重</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174234266-1575111287.png" alt></p><p><strong>2.复制（Copying）</strong></p><p>此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。</p><p>缺点： 持续复制，效率低。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174237703-328169343.png" alt></p><p><strong>3.Mark-Compact 标记-压缩(老年代使用)</strong></p><p>此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239219-1187241876.png" alt></p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><strong>1.Serial（串行GC）收集器</strong></p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174240391-864339858.png" alt></p><p><strong>2.ParNew（并行GC）收集器</strong></p><p>Serial 的多线程版本，新生代并行，复制算法，老年代串行，标记-压缩算法。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174244797-1533472044.png" alt></p><p><strong>3.Parallel Scavenge(并行回收GC)收集器</strong></p><p>类似ParNew,他关注的系统的吞吐量，也可以通过参数实现自适应性调节控制吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><p><strong>4.Parallel Old 收集器</strong></p><p>一种以最短停顿为目标的收集器</p><blockquote><p>初始标记（initial mark） stop-the-world,标记gc roots 直接关联对象。</p><p>并发标记（concurrent mark）trace gc roots</p><p>重新标记（remark） stop-the-world</p><p>并发清除（concurrent sweep）</p></blockquote><p>优点：并发收集，低停顿；</p><p>缺点：大量碎片；并发阶段；</p><p><strong>5.CMS 收集器</strong></p><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤：</p><p>①.初始标记(CMS initial mark)</p><p>②.并发标记(CMS concurrenr mark)</p><p>③.重新标记(CMS remark)</p><p>④.并发清除(CMS concurrent sweep)</p><p><strong>6.G1 回收器（Garbage First）</strong></p><p>面向服务器的收集器，主要针对配备多处理器 及大容量的内存的机器，以极高概率，满足GC停顿时间，且具备高吞吐量。</p><blockquote><p><strong>空间整合</strong>，G1收集器采用<strong>标记整理算法</strong>，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</p></blockquote><blockquote><p><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p></blockquote><p><strong>收集步骤：</strong></p><ol><li><p>标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)。</p></li><li><p>Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。</p></li><li><p>Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p></li></ol><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174249203-774809988.png" alt></p><ol><li><p>Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。</p></li><li><p>Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。</p></li></ol><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174250656-1729618538.png" alt></p><p>复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174252078-703896755.png" alt></p><hr><p>参考：</p><p><a href="https://blog.csdn.net/hui_yan2012/article/details/70194449" target="_blank" rel="noopener">https://blog.csdn.net/hui_yan2012/article/details/70194449 </a></p><p><a href="https://blog.csdn.net/qq_33384065/article/details/80282023" target="_blank" rel="noopener">https://blog.csdn.net/qq_33384065/article/details/80282023</a></p><p><a href="https://blog.csdn.net/supera_li/article/details/45747589" target="_blank" rel="noopener">https://blog.csdn.net/supera_li/article/details/45747589</a></p><p><a href="https://blog.csdn.net/java2000_wl/article/details/8030172" target="_blank" rel="noopener">https://blog.csdn.net/java2000_wl/article/details/8030172</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java由四方面组成：&quot;&gt;&lt;a href=&quot;#java由四方面组成：&quot; class=&quot;headerlink&quot; title=&quot;java由四方面组成：&quot;&gt;&lt;/a&gt;java由四方面组成：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java编程语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java类文件格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java虚拟机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java应用程序接口(Java API)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关系如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/07/03/ZtdL4S.gif&quot; alt=&quot;image text&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Java虚拟机体系结构&quot;&gt;&lt;a href=&quot;#1-Java虚拟机体系结构&quot; class=&quot;headerlink&quot; title=&quot;1.Java虚拟机体系结构&quot;&gt;&lt;/a&gt;1.Java虚拟机体系结构&lt;/h1&gt;
    
    </summary>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>博客的搭建</title>
    <link href="http://yoursite.com/2019/07/02/%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2019/07/02/博客的搭建/</id>
    <published>2019-07-02T06:22:02.000Z</published>
    <updated>2019-07-02T06:43:32.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitPage的优点"><a href="#GitPage的优点" class="headerlink" title="GitPage的优点"></a>GitPage的优点</h2><ul><li>可以绑定你的域名(但暂时貌似只能绑定一个)。</li><li>简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。</li><li>轻量级的博客系统，没有麻烦的配置</li><li>使用标记语言，比如 Markdown</li></ul><a id="more"></a><h2 id="hexo-构建静态文件无法生成-index-html-等文件"><a href="#hexo-构建静态文件无法生成-index-html-等文件" class="headerlink" title="hexo 构建静态文件无法生成 index.html 等文件"></a>hexo 构建静态文件无法生成 index.html 等文件</h2><h5 id="查看npm安装hexo插件情况"><a href="#查看npm安装hexo插件情况" class="headerlink" title="查看npm安装hexo插件情况"></a>查看npm安装hexo插件情况</h5><blockquote><p>npm ls –depth 0</p></blockquote><p>一些插件未安装</p><p><img src="http://huihut-img.oss-cn-shenzhen.aliyuncs.com/ganningZHexoNPMls.png" alt="Image text"></p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>逐一安装缺失的包</p><blockquote><p> npm install hexo-generator-archive –save</p><p> npm install hexo-xxx-xxx –save</p><p> …</p></blockquote><hr><h2 id="执行hexo-server出现Usage-hexo-”的提示"><a href="#执行hexo-server出现Usage-hexo-”的提示" class="headerlink" title="执行hexo server出现Usage: hexo ”的提示"></a>执行hexo server出现Usage: hexo <command>”的提示</h2><p>出现这个原因是因为没有安装 hexo-server</p><h1 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h1><blockquote><p>npm install hexo-server –save</p></blockquote><hr><p>#部署GitHub</p><p>运行时出错，是没有添加sshkey</p><h3 id="一、生成新的SSH密钥"><a href="#一、生成新的SSH密钥" class="headerlink" title="一、生成新的SSH密钥"></a>一、生成新的SSH密钥</h3><p>1、打开Git Bash。</p><p>2、 进入.ssh 根目录下。</p><pre><code>cd ~/.ssh</code></pre><p>3、输入GitHub电子邮件地址，其中<a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a>是您关联的GitHub邮箱。</p><pre><code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code></pre><p>4、输入保存的密钥文件并接受默认文件地址，按Enter键</p><blockquote><p>// 用提供的电子邮件作为标签创建一个新的ssh密钥。（无需操作）</p></blockquote><blockquote><p>Generating public/private rsa key pair. </p></blockquote><blockquote><p>// 输入名称并按Enter键，其中hexo_rsa可自行设置</p></blockquote><blockquote><p>Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):hexo_rsa</p></blockquote><p>5、输入安全密码，没有则为空，按Enter键进行下一步</p><blockquote><p>Enter passphrase (empty for no passphrase): [Type a passphrase]<br>Enter same passphrase again: [Type passphrase again]</p></blockquote><p><img src="https://segmentfault.com/img/bVbn2Yk?w=574&h=318" alt="Image text"></p><blockquote><p>Your identification has been saved in /home/you/.ssh/id_rsa.</p><p>Your public key has been saved in /home/you/.ssh/id_rsa.pub.</p><p>The key fingerprint is:</p><p>…………………此处是密钥内容…………………… <a href="mailto:your_email@example.com" target="_blank" rel="noopener">your_email@example.com</a></p></blockquote><p>此时，应该在默认路径下，生成了两个文件，一个是hexo_rsa，另一个是hexo_rsa.pub；</p><p>###二、将SSH密钥添加到SSH-Agent</p><p>在将新的SSH密钥添加到SSH-Agent管理密钥之前，您应该检查现有的SSH密钥。</p><pre><code>ls -al ~/ .ssh</code></pre><p>看下返回的结果中是否已经存在了.pub结尾的文件，如果没有需要生成一个新的，如果存在了，直接看将SSH密钥配置到Github账户；</p><p>6、启动ssh-agent，执行命令：</p><pre><code>eval $(ssh-agent -s)</code></pre><p><img src="https://image-static.segmentfault.com/248/865/2488652781-5c53c17548630_articlex" alt="Image text"></p><p>7、将SSH密钥添加到SSH-Agent,其中hexo_rsa是生成SSH设置的名称</p><pre><code>ssh-ADD~ /.ssh/hexo_rsa</code></pre><p>8、打开hexo_rsa.pub文件，复制其内容，然后打开Github账户，按图片步骤设置，最后将复制内容放置Key内容中，设置title，点击添加即可。</p><p><img src="https://image-static.segmentfault.com/234/007/2340075688-5c53c333cacd3_articlex" alt="Image text"></p><p>验证SSH链接是否成功，<br>输入命令：</p><pre><code>ssh -T git@github.com</code></pre><p>你将会看到</p><p><img src="https://image-static.segmentfault.com/166/300/1663009123-5c53c4d35cc8c_articlex" alt="Image text"></p><p>输入 “Yes”就ok了！</p><hr><p>###相关连接：<br><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitPage的优点&quot;&gt;&lt;a href=&quot;#GitPage的优点&quot; class=&quot;headerlink&quot; title=&quot;GitPage的优点&quot;&gt;&lt;/a&gt;GitPage的优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;可以绑定你的域名(但暂时貌似只能绑定一个)。&lt;/li&gt;
&lt;li&gt;简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。&lt;/li&gt;
&lt;li&gt;轻量级的博客系统，没有麻烦的配置&lt;/li&gt;
&lt;li&gt;使用标记语言，比如 Markdown&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/06/30/hello-world/"/>
    <id>http://yoursite.com/2019/06/30/hello-world/</id>
    <published>2019-06-30T06:06:47.014Z</published>
    <updated>2019-07-01T15:57:06.323Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
