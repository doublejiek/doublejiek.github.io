<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[监理工程师]]></title>
    <url>%2F2019%2F09%2F06%2F%E7%9B%91%E7%90%86%E5%B7%A5%E7%A8%8B%E5%B8%88%2F</url>
    <content type="text"><![CDATA[工作流程1.监理设计：项目联络人和职责表、项目三级对标（目标、标书、标准）、项目关键里程碑节点时间、项目检核表设计 （1)项目联络人和职责表 与客户接触后第一件事情是取得项目干系人（业主单位、承建单位）的联&gt; 系方式和联系邮件、微信号（QQ号）。 经过用户主要干系人审核确认后，以电子邮件的形式（PDF格式）发给全体干系人，注意：要给业主方领导一份。 建立本项目专属微信群或QQ群。有新的人员加入后，本表需立即更新。 （2）项目三级对标 目标对标：公司内部，由现场实施部门召集，销售人员、有关技术支持人员参与，重点交流该项目的沿革、背景、各参与单位的基本情况、我公司参与投标情况、竞争对手参与本项目的情况、建设单位对项目的要求、承建单位的招投标情况及业主单位对承建单位招标的反馈、本项目的造价控制目标、进度控制要求、质量等级要求、建设单位相关人员情况等。 标书对标：项目现场或公司，由项目总监召集，建设单位、承建单位、现场监理人员、相关技术支持人员参与。重点交流该项目的技术线路、技术构成、投标后项目清单组成、项目总工期、各里程碑节点时间和标志的确定、各分项施工工艺和技术方法、施工纪律和作息时间、安全施工保证措施，同时需重点比对承建单位投标书与建设单位招标书之间的差距，如存在未在投标文件明确说明的负偏离，需与建设单位（甲方）汇报后另行处理。 标准对标：项目现场或公司，有项目总监召集，承建单位和现场监理人员和相关技术支持人员参与，建设单位可参与。重点确定本项目各子项目所适用的建设标准（国际、国家、省市地方标准），统一各方对项目质量标准的认识。 另：目标对标为公司内部会议，会议内容及纪要不对外；目标对标在监理项目正式进场前3天完成。 标书对标可在承建单位编写的项目实施方案的基础上进行，可事前将目录要求提交乙方。标书对标在承建单位进场后3天内完成。 标准对标前项目总监需事先列出常用（国标、国家）标准，供双方讨论、由国家强制标准的，坚持使用国家强制标准。标准对标在承建单位进场后7天内完成。 （3）项目关键里程碑节点时间 标书对标完成后3日内完成 根据标书对标和用户的进度要求，初步划分出工程的若干进度节点，如：主要设备到场时间、硬件系统完成时间、软件编码完成时间、系统试运行时间、验收时间等 评定工程节点采取倒排工期＋必要时间＋缓冲时间的方式，即以最后完工日期为准，综合考虑实际工作必要时间，并适当考虑缓冲时间。 必要时间：完成一项工作至少需要的时间，如小型机等定制设备、CISCO 高端路由器，需从国外订货，时间周期至少为2－3个月， 机房装饰部分至少需要1－2个月的建筑工期等。缓冲时间：在每个时间节点中，预留1周左右的缓冲时间，避免意外造成的偏差。 项目关键里程碑节点时间确定后，应该立即与业主方进行沟通，经过确认后，正式以文字版（签字、盖章，一式四份，业主、监理各两份）和电子版本（pdf）分发给有关干系人。 （4)检核表设计 标书对标完成后3日内完成 2.现场工作过程：项目首次会议、倒计时牌、各阶段性检核、旁站（现场督导施工进行）、项目变更、设备签收、周报和会议记录 (1)进程程序 监理进场前一定要经过监理设计阶段，如考虑到工期紧张等因素可以采取边进场边设计的方式。正式进场手续包括以下步骤： 1、 电话通知业主方主要干系人，商量监理正式进场时间 2、 将前期监理设计阶段工作向甲方做简要汇报 3、 甲方签署开工手续。 4、 召开首次会议 （2）首次会议 监理首次会议主要的目的是确定工作的基本制度及方法。参加人员有业主方主要干系人、承建单位的项目经理。 1、 与甲方商量好首次会议时间，并已电话通知相关人 2、 监理公司出席首次会议人员不得少于2人，1人负责会议介绍，1人负责会议记录和相关文件的分发 3、 由业主主持本次会议 4、 监理代表宣布项目制度和方法 5、 由业主单位或监理单位宣读已确认的项目关键里程碑节点时间 6、 传送相关电子文件格式，并请接收人签字确认 7、 整理会议纪要，并请各方签字 （3）倒计时牌 500万以下项目至少需要3个里程碑节点时间和倒计时 500万以上项目至少需要5个里程碑节点时间和倒计时 （4）阶段性检核 项目维度包括： 1、 前期资料完整性检核表（针对甲方） 一次性 2、 承建单位合同评估检核表 一次性 3、 进度评估（监理进度比对、倒计时牌） 周期性 4、 安全文明施工 周期性 5、 培训完成情况检核表 一次性 6、 运维和售后检核表 一次性 7、 项目验收准备检核表 周期性（一次） 技术维度包括： 1、 机房及监控中心（设计、实施） 2、 室内装修设计（设计、实施） 3、 配电及UPS系统（设计、实施） 4、 消防及弱电系统（设计、实施） 5、 防雷及接地（设计、实施） 6、 结构化布线系统（设计、实施） 7、 涉密系统布线（设计、实施） 8、 无线系统（设计、实施） 9、 安防系统（设计、实施） 10、 网络系统（设计、实施） 11、 网络安全系统（设计、实施） 12、 服务器系统（设计、实施） 13、 存储系统（设计、实施） 14、 软件需求规格说明书检核（实施） 15、 软件概要设计（实施） 16、 软件编码规范（设计、实施） （5）旁站 对隐蔽工程、重点环节进行旁站监理，即由监理工程师现场督导施工进行。旁站需要填写旁站记录表并配上相关照片，对发现的问题，及时下通知单。 （6）设备（材料）签收 设备（材料）原则上需经过签收方可在项目中使用。 工程中使用的大批量材料（如线缆、桥架、杆件等）乙方提供样品，进行抽检。 检查过程一定要做到资料齐全，相关产品的厂家合格证、3C（QC）证明材料、售后服务材料需齐全。 每一套设备的全部资料单独成册放置。 严格对应合同中的设备材料清单，逐一清点，如发现有误，立即以书面形式通知业主和承建方，同时暂停该设备（材料）的使用。 设备检验和清点完成后，粘贴公司监理专用二维码，方便后续管理。 （7）项目变更 原则上避免项目发生重大变更，确需变更的，按以下程序和方法进行： 1、 由乙方发起项目变更，阐明变更理由； 2、 监理召开变更专题会，邀请业主单位、承建单位论证变更的必要性和可行性； 3、 项目全部变更额度不超过项目造价的10%，如超过10%，将无法完成后续审计工作，可提请甲方对该项变更进行独立采购。 4、 如只是数量上变更，单价参照承建单位投标文件及合同，型号发生变更的，如配置比原配置高，价格可参照原投标文件及合同，如配置比原配置低，变更不予受理或建议提请重新招标。 5、 特殊情况下，可申请召开专家评审会，邀请业内专家和采购专家对变更进行论证和认定。 （8）周报和会议纪要 ①会议时间、主题 ②参加人（附会议签到表） ③会议议程 ④会议形成的决议 3.项目验收过程:项目培训记录、项目试运行记录、项目测试报告、检测报告、组织项目验收会议并出具项目验收报告 （1）项目培训过程记录 全程跟踪项目培训工作，在培训开始前要求承建单位提交培训计划，经甲方同意后，正式开始进行培训。 监理工程师做好培训期间的记录，建议监理工程师旁站参与各项培训。 （2）项目试运行记录 重点跟踪项目试运行，监理工程师做好试运行期间的试运行情况记录。 项目试运行记录包括项目试运行期间的设备和系统状态的记录，试运行中出现问题的跟踪记录，各方在项目试运行过程中提出的意见和建议等。 （3）软件测试报告 对工程全部子项均需要进行测试，未经测试的子项不得进入验收。测试工作的基本程序为: 1、 监理工程师下达书面测试指令，要求承建单位组织测试，并提交测试计划 2、 按照测试计划逐项测试，监理工程师做好全程测试记录和跟踪 3、 对测试中暴露出来的问题，下达整改通知单 4、 与验收标准中的有关指标和功能进行比对，达到要求的认为测试通过，未达到要求的，下达整改 5、 出具验收评估意见 测试评估意见至少包括以下内容： 1、 测试工作的基本情况（开始结束时间、测试内容、方法、测试人） 2、 测试中暴露出来的问题和应对措施 3、 监理工程师的测试评估意见 （4）运行监测报告 对信息系统的软硬件环境进行7*24小时在线监测 （5）组织项目验收 工程全部子项目测试均完毕、试运行完成，项目可以进入验收阶段，基本程序为： 1、 承建单位提出验收申请 2、 由监理工程师组织业主单位、承建单位召开三方会议，讨论确定验收方案 3、 制订验收文档目录和要求 4、 组织验收文档的编写和装订工作（监理、承建单位各自出具验收文档） 5、 监理工程师编写监理工作报告（简要介绍本项目的基本情况、监理工作目标、监理工作的日常情况、各项目标的完成情况和监理公司对本项目评估意见等） 6、 监理公司拟定评审专家名单 7、 拟定专家评审意见 8、 召开专家验收评审会，监理工程师负责记录，并宣读监理工作报告 9、 协助出具项目验收意见，要求业主、建设单位在验收文档签字盖章。 10、 文档的归类和整理，移交（移交工作需有移交清单） （6）项目撤场 项目验收完成后，监理工程师开始撤场，项目撤场程序为：1、 拟定移交资产清单并逐一移交（请业主方签字） 2、 请业主方填写服务评价表 3、 协助财务人员进行收款 4、 向业主单位提交售后服务联络表和推荐单位表 5、 现场清洁卫生，完成此项工作后，监理工程师撤场。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL]]></title>
    <url>%2F2019%2F09%2F06%2FSQL%2F</url>
    <content type="text"><![CDATA[基本语句show databases； 查询数据库服务器所有数据库 mysql&gt; show databases -&gt; ; +--------------------+ | Database | +--------------------+ | information_schema | | html | | musicplayer | | mybatis | | mysql | | springboot | | test | | ym-ehr-oa | | zu | +--------------------+ 9 rows in set (0.00 sec)select * from person； 查询数据库表中的记录（数据） 报错1046(3D000) mysql&gt; select*from admin -&gt; ; ERROR 1046 (3D000): No database selected use test； 切换数据库 mysql&gt; use test Database changedselect *from person；查询数据库表中的记录（数据） mysql&gt; select*from person; +----+------+ | id | name | +----+------+ | 1 | w| | 2 | j| | 3 | k| +----+------+ 3 rows in set (0.00 sec)create database demo；创建数据库 mysql&gt; create database demo -&gt; ; Query OK, 1 row affected (0.00 sec) mysql&gt; use demo Database changedshow tables；显示数据库中的所有表 mysql&gt; show tables -&gt; ; +----------------+ | Tables_in_demo | +----------------+ | pet | +----------------+ 1 row in set (0.00 sec)describe pet；显示表中的字段 mysql&gt; describe pet; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | neme | varchar(20) | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 1 row in set (0.01 sec)INSERT INTO pet VALUES(‘猪猪’,’公’,’2019-2-2’);向表中添加记录 mysql&gt; INSERT INTO pet VALUES(&apos;猪猪&apos;,&apos;公&apos;,&apos;2019-2-2&apos;); Query OK, 1 row affected (0.01 sec)delet from pet where name=’’;删除一条记录 update pet set name=’’ where owener=’’; 约束主键约束 唯一确定一张表的一条记录，为主键的字段不能为空不能重复。 创建时未添加主键，之后补充上 alter table user add primary key(id); 删除主键 alter table user drop primary key; 联合主键 只要主键值加起来不重复就可以 create table into user( id int, name varchar, primary key(id,name) );自增约束 create table user( id int primary key auto_increment, name varchar(20) );唯一约束修饰的字段的值不可以重复(可以为空) alter table user add unique (name); create table into user( id int, name varchar, unique(id,name) ); alter table user modify name varchar(20) unique;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mybatis-genneraror自动生成]]></title>
    <url>%2F2019%2F07%2F23%2FMybatis-genneraror%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[##Maven安装 在该文件中配置仓库存放的位置和仓库镜像 &lt;localRepository&gt;F:\java\apache-maven-3.3.9\repo&lt;/localRepository&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 配合eclipse使用 windows–&gt;Preferences–&gt;Maven–&gt;Installations 然后到User Setting中 新建Maven Project ##pom文件导入依赖包 在pom文件中 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;qq-login&lt;/groupId&gt; &lt;artifactId&gt;qq-login&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Spring Boot 父组件 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.9.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--属性值 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;/properties&gt; &lt;!-- Spring Boot web 模块 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 可执行jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt;代码生成器&lt;!-- mybatis-generator自动生成 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.4&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; /resource/generator/generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- 配置信息 --&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;!-- 配置生成器 生成 命令 mybatis-generator:generate --&gt; &lt;generatorConfiguration&gt; &lt;!-- &lt;properties resource=&quot;application.yml&quot;/&gt; --&gt; &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt; &lt;!-- beginningDelimiter和endingDelimiter：指明数据库的用 于标记数据库对象名的符号，比如ORACLE就是双引号，MYSQL默认是`反引号；--&gt; &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt; &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt; &lt;!-- 数据库连接地址账号密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/ym-ehr-oa&quot; userId=&quot;root&quot; password=&quot;123456&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- java模型创建器，是必须要的元素负责： 1，key类（见context的defaultModelType）;2，java类;3，查询类 targetPackage：生成的类要放的包，真实的包受; enableSubPackages属性控制； targetProject：目标项目，指定一个存在的目录下，生成的内容会放到指定目录中，如果目录不存在，MBG不会自动建目录 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.ehr.model&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;sqlMapGenerator targetPackage=&quot;com.ehr.dao.mapper&quot; targetProject=&quot;src/main/java&quot;/&gt; &lt;javaClientGenerator targetPackage=&quot;com.ehr.dao&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;/&gt; &lt;!--自动生成的表 --&gt; &lt;table tableName=&quot;ehr_position&quot; domainObjectName=&quot;Pos&quot; mapperName=&quot;PosDao&quot; &gt; &lt;!--mysql 配置--&gt; &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;Mysql&quot; identity=&quot;true&quot;/&gt; &lt;/table&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt;生成命令 生成 命令 mybatis-generator:generate勾选跳过测试]]></content>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2F2019%2F07%2F10%2F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[框架ORMHibernate（JPA） 一个开源的对象关系映射框架 对JDBC进行了非常轻量级的对象封装 将JacaBean对象和数据库的表建立对应关系 它是一个优秀的Java持久化层（DAO）解决方案 是当今主流的对象——关系映射工具 它简化了JDBC繁琐的编码，将数据库的连接信息都放置在配置文件中 ####Mybatis MyBatis是一个支持普通SQL查询，存储过程和高级映射的优秀持久层框架。 MyBatis消除了几乎所有的JDBC代码和参数的手工设置以及对结果集的检索封装。 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录。 ####Hibernate和Mybatis的区别 一、MyBatis 真正实现了java代码和sql的分离 二、Hibernate 是全自动的，MyBatis是半自动的 Hibernate实现了部分自动生成SQL 三、SQL优化上 MyBatis 强于 Hibernate 1、MyBatis优化维护方便 SQL全存在于XML中 不需要修改源代码 2、开发效率上 Hibernate略强于mybatiss 3、从性能上说，对性能要求不是很高的项目来说，因为Mybatis全都 是自己手写的SQL 因此性能相对较高， Hibernate更加提倡使用HQL HQL往往会查询更多的字段，性能反而 较低。 4、从更新功能上来说 Hibernate会更新所有字段 而MyBatis可以 只需要更新意个字段 5、Hibernate相对来说简化了DAO类的书写 ##Spring MVC SpringMVC是一种基于Java，实现了Web MVC设计模式，请求驱动类型的轻量级Web框架，将Web层进行职责解耦。（请求驱动即 请求-响应模型） 浏览器识别程序的桥梁 Model 实体类 数据库的映射类 View 视图 页面 Controller 控制器 通信代码 Spring 一站式框架web层：Spring MVC 业务层（Service）：Spring的Bean管理，声明式事务 持久层（DAO）：ORM模块、JDBC模板 对象-关系映射（OBJECT/RELATIONALMAPPING，简称ORM），是随着面向对象的软件开发方法发展而产生的。用来把对象模型表示的对象映射到基于S Q L 的关系模型数据库结构中去。这样，我们在具体的操作实体对象的时候，就不需要再去和复杂的 SQ L 语句打交道，只需简单的操作实体对象的属性和方法。ORM技术是在对象和关系之间提供了一条桥梁，前台的对象型数据和数据库中的关系型的数据通过这个桥梁来相互转化。 ##MavenMaven 导入jar包 ##注解 @RequestMapper 地址路由连接器 @RequestMapping(“/”)`这个(“/”) 就是浏览器要寻找的程序地址 @ResponseBody 注解就是返回的数据格式为json没加代表返回的数据格式是页面 @RequestMapping(&quot;/json&quot;) @ResponseBody IOC注解@Component ：组件其三个衍生注解（功能类似），修饰类： @Controller ：web层（带有@Controller的程序类才能被浏览器识别） @Service ：service层 @Repository ：dao层 属性注入的注解普通属性： @Value ：设置普通属性的值 对象类型属性： @Autowired ：设置对象类型的属性值，但 是按照类型 完成属性注入（相当于引用这个类） @Qualifier（value=””）：按名称完成属性注入 @Resource（name=””） ：按名称完成属性注入 其他注解Bean作用范围的注解 @Scope ：作用范围 @Scope(singleton) ：默认单例 @Scope(prototype) ：多例 ##jquery三大选择器Id选择器 ——》 $(#id) Class 选择器 –》 $(.class) Element 标签选择器 $(Element ) jquery 绑定点击事件 $(&quot;#btn&quot;).click(function(){ alert(“点击了”) });jQuery方法 Val() 取值 val(123) 设置 attr() 取属性值 attr(“name”,”kd”) 设置 Append() 追加方法 Html()替换html方法 Each(data,function(index,item)) 循环方法##Ajax Ajax 是异步请求后台数据的方法，可以局部刷新页面 $.post(地址,参数,回调地址) Get 也一样 $.get(地址,参数,回调地址) $.post(&quot;/loginCheck&quot;,{&quot;name&quot;:name,&quot;pwd&quot;:pwd},function(json){ //成功跳转页面，不成功则登录页面弹出对话框 if(json.msg==&quot;yes&quot;){ location.href=&quot;/user/list&quot;; }else{ alert(&quot;登录失败&quot;) } }) // 登录验证 @RequestMapping(&quot;/loginCheck&quot;) @ResponseBody public Map&lt;String, Object&gt; loginCheck(String name,String pwd) { Map&lt;String, Object&gt;map=new HashMap&lt;&gt;(); if(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)){ map.put(&quot;msg&quot;, &quot;yes&quot;); }else{ map.put(&quot;msg&quot;, &quot;no&quot;); //控制台 System.out.println(&quot;登录失败&quot;); } return map; }IOC和DIIOC：控制反转 将对象的创建权反转给Spring 下载jar开发包 引入jar包 创建接口和实现类 将接口和实现类交给Spring管理 编写测试类 DI：依赖注入 前提必须有IOC环境，Spring管理这个类的时候将这个类的依赖属性注入（设置）进来AOP（面向切面编程）：AOP的开发对程序进行扩展 Spring开发包 dosc：开发规范和API libs：jar和源码 shema：配置文件和约束]]></content>
  </entry>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2019%2F07%2F03%2FJVM%2F</url>
    <content type="text"><![CDATA[java由四方面组成： Java编程语言 Java类文件格式 Java虚拟机 Java应用程序接口(Java API) 关系如下图： 1.Java虚拟机体系结构 每个JVM都有两种机制 ①类装载子系统：装载具有适合名称的类或接口 ②执行引擎：负责执行包含在已装载的类或接口中的指令 #2.Java代码编译和执行的整个过程 开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。 （1）Java代码到JVM字节码（编译） （2）JVM字节码到机器码（执行） 编译到运行的三个机制（1）Java源码编译机制 ①分析和输入到符号表 ②注解处理 ③语义分析和生成CLASS文件 最后生成的class文件由以下部分组成： ①结构信息：包括class文件格式版本号及各部分的数量与大小的信息 ②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池 ③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息 （2）类加载机制 1.装载load 。目的是生成类加载实例id 2.链接 ，检测字节码格式以及内部调用匹配情况。静态变量初始化 3.初始化。主要是类加载器加载类的顺序。 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 （3）类执行机制 JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示： 3.JVM内存管理及垃圾回收机制JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用） 垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。 垃圾检测：可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象本地方法中引用的对象等。 JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。 GC算法1.标记-清除（Mark-sweep） 分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。 缺点：效率低；碎片化严重 2.复制（Copying） 此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。 缺点： 持续复制，效率低。 3.Mark-Compact 标记-压缩(老年代使用) 此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。 垃圾回收器1.Serial（串行GC）收集器 2.ParNew（并行GC）收集器 Serial 的多线程版本，新生代并行，复制算法，老年代串行，标记-压缩算法。 3.Parallel Scavenge(并行回收GC)收集器 类似ParNew,他关注的系统的吞吐量，也可以通过参数实现自适应性调节控制吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。 4.Parallel Old 收集器 一种以最短停顿为目标的收集器 初始标记（initial mark） stop-the-world,标记gc roots 直接关联对象。 并发标记（concurrent mark）trace gc roots 重新标记（remark） stop-the-world 并发清除（concurrent sweep） 优点：并发收集，低停顿； 缺点：大量碎片；并发阶段； 5.CMS 收集器 CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤： ①.初始标记(CMS initial mark) ②.并发标记(CMS concurrenr mark) ③.重新标记(CMS remark) ④.并发清除(CMS concurrent sweep) 6.G1 回收器（Garbage First） 面向服务器的收集器，主要针对配备多处理器 及大容量的内存的机器，以极高概率，满足GC停顿时间，且具备高吞吐量。 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 收集步骤： 标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)。 Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 参考： https://blog.csdn.net/hui_yan2012/article/details/70194449 https://blog.csdn.net/qq_33384065/article/details/80282023 https://blog.csdn.net/supera_li/article/details/45747589 https://blog.csdn.net/java2000_wl/article/details/8030172]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的搭建]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[GitPage的优点 可以绑定你的域名(但暂时貌似只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 轻量级的博客系统，没有麻烦的配置 使用标记语言，比如 Markdown hexo 构建静态文件无法生成 index.html 等文件查看npm安装hexo插件情况 npm ls –depth 0 一些插件未安装 解决逐一安装缺失的包 npm install hexo-generator-archive –save npm install hexo-xxx-xxx –save … 执行hexo server出现Usage: hexo ”的提示出现这个原因是因为没有安装 hexo-server 解决 npm install hexo-server –save #部署GitHub 运行时出错，是没有添加sshkey 一、生成新的SSH密钥1、打开Git Bash。 2、 进入.ssh 根目录下。 cd ~/.ssh3、输入GitHub电子邮件地址，其中your_email@example.com是您关联的GitHub邮箱。 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;4、输入保存的密钥文件并接受默认文件地址，按Enter键 // 用提供的电子邮件作为标签创建一个新的ssh密钥。（无需操作） Generating public/private rsa key pair. // 输入名称并按Enter键，其中hexo_rsa可自行设置 Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):hexo_rsa 5、输入安全密码，没有则为空，按Enter键进行下一步 Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] Your identification has been saved in /home/you/.ssh/id_rsa. Your public key has been saved in /home/you/.ssh/id_rsa.pub. The key fingerprint is: …………………此处是密钥内容…………………… your_email@example.com 此时，应该在默认路径下，生成了两个文件，一个是hexo_rsa，另一个是hexo_rsa.pub； ###二、将SSH密钥添加到SSH-Agent 在将新的SSH密钥添加到SSH-Agent管理密钥之前，您应该检查现有的SSH密钥。 ls -al ~/ .ssh看下返回的结果中是否已经存在了.pub结尾的文件，如果没有需要生成一个新的，如果存在了，直接看将SSH密钥配置到Github账户； 6、启动ssh-agent，执行命令： eval $(ssh-agent -s) 7、将SSH密钥添加到SSH-Agent,其中hexo_rsa是生成SSH设置的名称 ssh-ADD~ /.ssh/hexo_rsa8、打开hexo_rsa.pub文件，复制其内容，然后打开Github账户，按图片步骤设置，最后将复制内容放置Key内容中，设置title，点击添加即可。 验证SSH链接是否成功，输入命令： ssh -T git@github.com你将会看到 输入 “Yes”就ok了！ ###相关连接：https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
