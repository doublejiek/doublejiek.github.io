<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM]]></title>
    <url>%2F2019%2F07%2F03%2FJVM%2F</url>
    <content type="text"><![CDATA[java由四方面组成： Java编程语言 Java类文件格式 Java虚拟机 Java应用程序接口(Java API) 关系如下图： 1.Java虚拟机体系结构 每个JVM都有两种机制 ①类装载子系统：装载具有适合名称的类或接口 ②执行引擎：负责执行包含在已装载的类或接口中的指令 #2.Java代码编译和执行的整个过程 开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。 （1）Java代码到JVM字节码（编译） （2）JVM字节码到机器码（执行） 编译到运行的三个机制（1）Java源码编译机制 ①分析和输入到符号表 ②注解处理 ③语义分析和生成CLASS文件 最后生成的class文件由以下部分组成： ①结构信息：包括class文件格式版本号及各部分的数量与大小的信息 ②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池 ③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息 （2）类加载机制 1.装载load 。目的是生成类加载实例id 2.链接 ，检测字节码格式以及内部调用匹配情况。静态变量初始化 3.初始化。主要是类加载器加载类的顺序。 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 （3）类执行机制 JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。 JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示： 3.JVM内存管理及垃圾回收机制JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用） 垃圾收集器一般必须完成两件事：检测出垃圾；回收垃圾。 垃圾检测：可达性分析算法：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象本地方法中引用的对象等。 JVM在做垃圾回收的时候，会检查堆中的所有对象是否会被这些根集对象引用，不能够被引用的对象就会被垃圾收集器回收。 GC算法1.标记-清除（Mark-sweep） 分为两个阶段：标记和清除。标记所有需要回收的对象，然后统一回收。这是最基础的算法，后续的收集算法都是基于这个算法扩展的。 缺点：效率低；碎片化严重 2.复制（Copying） 此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。 缺点： 持续复制，效率低。 3.Mark-Compact 标记-压缩(老年代使用) 此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。 垃圾回收器1.Serial（串行GC）收集器 2.ParNew（并行GC）收集器 Serial 的多线程版本，新生代并行，复制算法，老年代串行，标记-压缩算法。 3.Parallel Scavenge(并行回收GC)收集器 类似ParNew,他关注的系统的吞吐量，也可以通过参数实现自适应性调节控制吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)，虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。 4.Parallel Old 收集器 一种以最短停顿为目标的收集器 初始标记（initial mark） stop-the-world,标记gc roots 直接关联对象。 并发标记（concurrent mark）trace gc roots 重新标记（remark） stop-the-world 并发清除（concurrent sweep） 优点：并发收集，低停顿； 缺点：大量碎片；并发阶段； 5.CMS 收集器 CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，整个收集过程大致分为4个步骤： ①.初始标记(CMS initial mark) ②.并发标记(CMS concurrenr mark) ③.重新标记(CMS remark) ④.并发清除(CMS concurrent sweep) 6.G1 回收器（Garbage First） 面向服务器的收集器，主要针对配备多处理器 及大容量的内存的机器，以极高概率，满足GC停顿时间，且具备高吞吐量。 空间整合，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。 可预测停顿，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。 收集步骤： 标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young) (inital-mark)。 Root Region Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young GC之前完成。 Concurrent Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。 Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集 并发标记阶段 产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning (SATB)。 Copy/Clean up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember Sets，并发清空回收区域并把它返回到空闲区域链表中。 复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。 参考： https://blog.csdn.net/hui_yan2012/article/details/70194449 https://blog.csdn.net/qq_33384065/article/details/80282023 https://blog.csdn.net/supera_li/article/details/45747589 https://blog.csdn.net/java2000_wl/article/details/8030172]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的搭建]]></title>
    <url>%2F2019%2F07%2F02%2F%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[GitPage的优点 可以绑定你的域名(但暂时貌似只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 轻量级的博客系统，没有麻烦的配置 使用标记语言，比如 Markdown hexo 构建静态文件无法生成 index.html 等文件查看npm安装hexo插件情况 npm ls –depth 0 一些插件未安装 解决逐一安装缺失的包 npm install hexo-generator-archive –save npm install hexo-xxx-xxx –save … 执行hexo server出现Usage: hexo ”的提示出现这个原因是因为没有安装 hexo-server 解决 npm install hexo-server –save #部署GitHub 运行时出错，是没有添加sshkey 一、生成新的SSH密钥1、打开Git Bash。 2、 进入.ssh 根目录下。 cd ~/.ssh3、输入GitHub电子邮件地址，其中your_email@example.com是您关联的GitHub邮箱。 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;4、输入保存的密钥文件并接受默认文件地址，按Enter键 // 用提供的电子邮件作为标签创建一个新的ssh密钥。（无需操作） Generating public/private rsa key pair. // 输入名称并按Enter键，其中hexo_rsa可自行设置 Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):hexo_rsa 5、输入安全密码，没有则为空，按Enter键进行下一步 Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] Your identification has been saved in /home/you/.ssh/id_rsa. Your public key has been saved in /home/you/.ssh/id_rsa.pub. The key fingerprint is: …………………此处是密钥内容…………………… your_email@example.com 此时，应该在默认路径下，生成了两个文件，一个是hexo_rsa，另一个是hexo_rsa.pub； ###二、将SSH密钥添加到SSH-Agent 在将新的SSH密钥添加到SSH-Agent管理密钥之前，您应该检查现有的SSH密钥。 ls -al ~/ .ssh看下返回的结果中是否已经存在了.pub结尾的文件，如果没有需要生成一个新的，如果存在了，直接看将SSH密钥配置到Github账户； 6、启动ssh-agent，执行命令： eval $(ssh-agent -s) 7、将SSH密钥添加到SSH-Agent,其中hexo_rsa是生成SSH设置的名称 ssh-ADD~ /.ssh/hexo_rsa8、打开hexo_rsa.pub文件，复制其内容，然后打开Github账户，按图片步骤设置，最后将复制内容放置Key内容中，设置title，点击添加即可。 验证SSH链接是否成功，输入命令： ssh -T git@github.com你将会看到 输入 “Yes”就ok了！ ###相关连接：https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
